<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WangCode&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-12T07:25:59.190Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WangCode</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenGL ES Lesson 1</title>
    <link href="http://yoursite.com/2019/06/12/OpenGL-ES-Lesson-1/"/>
    <id>http://yoursite.com/2019/06/12/OpenGL-ES-Lesson-1/</id>
    <published>2019-06-12T06:36:49.000Z</published>
    <updated>2019-06-12T07:25:59.190Z</updated>
    
    <content type="html"><![CDATA[<p>本文目的在此记录学习OpenGL ES的心得.</p><p>我大致整理了一下入门OpenGL必须理解并掌握的知识点，如果没有这些知识点的积累，我觉得很难去下手学习OpenGL. </p><p>一. 渲染的基本流程</p><p><img src="https://learnopengl-cn.readthedocs.io/zh/latest/img/01/04/pipeline.png" alt="img"></p><p>可以从上图看出，我们可以简单的把顶点着色器理解为定义形状,片段着色器是渲染颜色的。</p><p>二. 坐标的变换</p><p><img src="http://zhangtielei.com/assets/photos_opengl_trans/part1/coordinate_system_overview.png" alt="åæ åæ¢æ¦è§å¾"></p><p>我们需要把本地坐标变换为屏幕坐标，也就是2D坐标。</p><p>三.Shader编程</p><p>着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。我们必须学会Shader编程,才说入门了OpenGL.</p><p>下面我用一个画三角形的经典例子来把上述的3个重要知识点串联起来过一遍,详细知识点会再接下来的博文中一一讲诉。</p><p>在Android中,我们用GLSurfaceView显示OpenGL ES画的图形.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mGLSurfaceView.setRenderer(new LessonOneRenderer());</span><br></pre></td></tr></table></figure><p>重点是LessonOneRenderer类,这个类通过实现Render接口来做操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final String vertexShader =</span><br><span class="line">   &quot;uniform mat4 u_MVPMatrix;      \n&quot;       // A constant representing the combined model/view/projection matrix.</span><br><span class="line">   </span><br><span class="line">  + &quot;attribute vec4 a_Position;     \n&quot;       // Per-vertex position information we will pass in.</span><br><span class="line">  + &quot;attribute vec4 a_Color;        \n&quot;       // Per-vertex color information we will pass in.           </span><br><span class="line">  </span><br><span class="line">  + &quot;varying vec4 v_Color;          \n&quot;       // This will be passed into the fragment shader.</span><br><span class="line">  </span><br><span class="line">  + &quot;void main()                    \n&quot;       // The entry point for our vertex shader.</span><br><span class="line">  + &quot;&#123;                              \n&quot;</span><br><span class="line">  + &quot;   v_Color = a_Color;          \n&quot;       // Pass the color through to the fragment shader. </span><br><span class="line">                                 // It will be interpolated across the triangle.</span><br><span class="line">  + &quot;   gl_Position = u_MVPMatrix   \n&quot;    // gl_Position is a special variable used to store the final position.</span><br><span class="line">  + &quot;               * a_Position;   \n&quot;     // Multiply the vertex by the matrix to get the final point in                                                                 </span><br><span class="line">  + &quot;&#125;                              \n&quot;;    // normalized screen coordinates.</span><br></pre></td></tr></table></figure><p>我们首先定义了一个顶点着色器,gl_Position = u_MVPMatrix*a_Position,这段代码的意思是通过坐标变换,转为屏幕坐标,也就是经过一系列的model,view,projection.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final String fragmentShader =</span><br><span class="line">   &quot;precision mediump float;       \n&quot;       // Set the default precision to medium. We don&apos;t need as high of a </span><br><span class="line">                                 // precision in the fragment shader.            </span><br><span class="line">  + &quot;varying vec4 v_Color;          \n&quot;       // This is the color from the vertex shader interpolated across the </span><br><span class="line">                                 // triangle per fragment.          </span><br><span class="line">  + &quot;void main()                    \n&quot;       // The entry point for our fragment shader.</span><br><span class="line">  + &quot;&#123;                              \n&quot;</span><br><span class="line">  + &quot;   gl_FragColor = v_Color;     \n&quot;       // Pass the color directly through the pipeline.        </span><br><span class="line">  + &quot;&#125;                              \n&quot;;</span><br></pre></td></tr></table></figure><p>此片段着色器就是通过顶点着色器传过来的v_color赋值给gl_FragColor.</p><p>接下来其实就是模板代码,我觉得可以抽象出一个类来做.不过现在为了理解流程，就没有抽象出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Load in the vertex shader.</span><br><span class="line">int vertexShaderHandle = GLES20.glCreateShader(GLES20.GL_VERTEX_SHADER);</span><br><span class="line"></span><br><span class="line">if (vertexShaderHandle != 0) </span><br><span class="line">&#123;</span><br><span class="line">   // Pass in the shader source.</span><br><span class="line">   GLES20.glShaderSource(vertexShaderHandle, vertexShader);</span><br><span class="line"></span><br><span class="line">   // Compile the shader.</span><br><span class="line">   GLES20.glCompileShader(vertexShaderHandle);</span><br><span class="line"></span><br><span class="line">   // Get the compilation status.</span><br><span class="line">   final int[] compileStatus = new int[1];</span><br><span class="line">   GLES20.glGetShaderiv(vertexShaderHandle, GLES20.GL_COMPILE_STATUS, compileStatus, 0);</span><br><span class="line"></span><br><span class="line">   // If the compilation failed, delete the shader.</span><br><span class="line">   if (compileStatus[0] == 0) </span><br><span class="line">   &#123;           </span><br><span class="line">      GLES20.glDeleteShader(vertexShaderHandle);</span><br><span class="line">      vertexShaderHandle = 0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是编译，连接上面的着色器语言。片段着色器类似，就不贴了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// Create a program object and store the handle to it.</span><br><span class="line">int programHandle = GLES20.glCreateProgram();</span><br><span class="line"></span><br><span class="line">if (programHandle != 0) </span><br><span class="line">&#123;</span><br><span class="line">   // Bind the vertex shader to the program.</span><br><span class="line">   GLES20.glAttachShader(programHandle, vertexShaderHandle);        </span><br><span class="line"></span><br><span class="line">   // Bind the fragment shader to the program.</span><br><span class="line">   GLES20.glAttachShader(programHandle, fragmentShaderHandle);</span><br><span class="line">   </span><br><span class="line">   // Bind attributes</span><br><span class="line">   GLES20.glBindAttribLocation(programHandle, 0, &quot;a_Position&quot;);</span><br><span class="line">   GLES20.glBindAttribLocation(programHandle, 1, &quot;a_Color&quot;);</span><br><span class="line">   </span><br><span class="line">   // Link the two shaders together into a program.</span><br><span class="line">   GLES20.glLinkProgram(programHandle);</span><br><span class="line"></span><br><span class="line">   // Get the link status.</span><br><span class="line">   final int[] linkStatus = new int[1];</span><br><span class="line">   GLES20.glGetProgramiv(programHandle, GLES20.GL_LINK_STATUS, linkStatus, 0);</span><br><span class="line"></span><br><span class="line">   // If the link failed, delete the program.</span><br><span class="line">   if (linkStatus[0] == 0) </span><br><span class="line">   &#123;           </span><br><span class="line">      GLES20.glDeleteProgram(programHandle);</span><br><span class="line">      programHandle = 0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">  // Tell OpenGL to use this program when rendering.</span><br><span class="line">        GLES20.glUseProgram(programHandle);</span><br></pre></td></tr></table></figure><p>最后就是通过programHandle通知GLES使用。</p><p>然后我们在onDrawFrame方法里画三角形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void drawTriangle(final FloatBuffer aTriangleBuffer)</span><br><span class="line">&#123;</span><br><span class="line">   // Pass in the position information</span><br><span class="line">   aTriangleBuffer.position(mPositionOffset);</span><br><span class="line">       GLES20.glVertexAttribPointer(mPositionHandle, mPositionDataSize, GLES20.GL_FLOAT, false,</span><br><span class="line">              mStrideBytes, aTriangleBuffer);        </span><br><span class="line">               </span><br><span class="line">       GLES20.glEnableVertexAttribArray(mPositionHandle);        </span><br><span class="line">       </span><br><span class="line">       // Pass in the color information</span><br><span class="line">       aTriangleBuffer.position(mColorOffset);</span><br><span class="line">       GLES20.glVertexAttribPointer(mColorHandle, mColorDataSize, GLES20.GL_FLOAT, false,</span><br><span class="line">              mStrideBytes, aTriangleBuffer);</span><br><span class="line">       </span><br><span class="line">       GLES20.glEnableVertexAttribArray(mColorHandle);</span><br><span class="line">       </span><br><span class="line">   // This multiplies the view matrix by the model matrix, and stores the result in the MVP matrix</span><br><span class="line">       // (which currently contains model * view).</span><br><span class="line">       Matrix.multiplyMM(mMVPMatrix, 0, mViewMatrix, 0, mModelMatrix, 0);</span><br><span class="line">       </span><br><span class="line">       // This multiplies the modelview matrix by the projection matrix, and stores the result in the MVP matrix</span><br><span class="line">       // (which now contains model * view * projection).</span><br><span class="line">       Matrix.multiplyMM(mMVPMatrix, 0,  mMVPMatrix, 0, mProjectionMatrix, 0);</span><br><span class="line"></span><br><span class="line">       GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mMVPMatrix, 0);</span><br><span class="line">       GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, 3);                               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先设置了缓冲区的位置偏移，然后把数据提供给了顶点着色器。最后经过矩阵变换把坐标投影到屏幕上了。</p><p><code>GLES20.glUniformMatrix4fv()</code>方法将最终的矩阵传入顶点着色器。<br><code>GLES20.glDrawArrays()</code>将我们的点转换为三角形并将其绘制在屏幕上。</p><p>这是截图</p><p><img src="https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/learn-opengl/20190122233309.png" alt="screenshot"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文目的在此记录学习OpenGL ES的心得.&lt;/p&gt;
&lt;p&gt;我大致整理了一下入门OpenGL必须理解并掌握的知识点，如果没有这些知识点的积累，我觉得很难去下手学习OpenGL. &lt;/p&gt;
&lt;p&gt;一. 渲染的基本流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lea
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为LinearLayout加入滑动以及分页效果</title>
    <link href="http://yoursite.com/2019/04/09/%E4%B8%BALinearLayout%E5%8A%A0%E5%85%A5%E6%BB%91%E5%8A%A8%E4%BB%A5%E5%8F%8A%E5%88%86%E9%A1%B5%E6%95%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2019/04/09/为LinearLayout加入滑动以及分页效果/</id>
    <published>2019-04-09T07:06:23.000Z</published>
    <updated>2019-04-10T09:00:32.827Z</updated>
    
    <content type="html"><![CDATA[<p>原来的项目主页就是一个LinearLayout,一共放了4个Item,现在的元素越来越多,一个屏幕已经放不下了,现在需要滑动翻页.为了能达到这个效果,把LinearLayout替换成Viewpager，这是一个可行的方案。但是对项目代码侵入性太大，需要重写很多逻辑。我想达到的效果是继续沿用原来的代码逻辑，后面如果增加了一个Item,只需在布局里面增加一个Item就可以了，什么也不用做。这样即实现了需求，代码又不用改多少。达到低侵入性的效果。</p><p>为了达到我的要求，只需使LinearLayout具备滑动功能即可,用Scroller这个类就能控制滑动。</p><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取TouchSlop值</span><br><span class="line">mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);</span><br></pre></td></tr></table></figure></li></ol><p>滑动像素超过上面的ToushSlop值就会判定为滑动，不然的话手点一下也会出现滑动，体验不好。</p><ol start="2"><li><p>重写onInterceptTouchEvent拦截事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    switch (ev.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            mXDown = ev.getRawX();</span><br><span class="line">            mXLastMove = mXDown;</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_MOVE:</span><br><span class="line">            mXMove = ev.getRawX();</span><br><span class="line">            float diff = Math.abs(mXMove - mXDown);</span><br><span class="line">            mXLastMove = mXMove;</span><br><span class="line">            // 当手指拖动值大于TouchSlop值时，认为应该进行滚动，拦截子控件的事件</span><br><span class="line">            if (diff &gt; mTouchSlop) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onInterceptTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在onTouchEvent方法里处理拦截事件,当滑动屏幕超过20%的时候,就调用scoller.startScroll方法进行滑动.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">case MotionEvent.ACTION_UP:</span><br><span class="line">    int move = (int) (mXLastMove - mXMove);</span><br><span class="line">    // 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个界面</span><br><span class="line">    int scrollx = getScrollX();</span><br><span class="line">    if (targetIndex == 1 &amp;&amp; (getWidth() - scrollx) &gt; 0.2 * getWidth()) &#123;</span><br><span class="line">        mScroller.startScroll(scrollx, 0, -scrollx, 0);</span><br><span class="line">        invalidate();</span><br><span class="line">        targetIndex = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        targetIndex = (int) (scrollx + 0.8 * getWidth()) / getWidth();</span><br><span class="line">        int dx = targetIndex * getWidth() - scrollx;</span><br><span class="line">        // 第二步，调用startScroll()方法来初始化滚动数据并刷新界面</span><br><span class="line">        mScroller.startScroll(scrollx, 0, dx, 0);</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    if (mPageListener != null) &#123;</span><br><span class="line">        mPageListener.onPage(targetIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure></li><li><p>最后重写computeScroll()方法</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void computeScroll() &#123;</span><br><span class="line">    // 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑</span><br><span class="line">    if (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author:xiaowang.li</span><br><span class="line"> * Date:26/03/2019</span><br><span class="line"> * Description:支持类似ViewPager的LineaLayout,通用性不好,以后来完善</span><br><span class="line"> */</span><br><span class="line">public class ScrollerLinearLayout extends LinearLayout &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 用于完成滚动操作的实例</span><br><span class="line">     */</span><br><span class="line">    private Scroller mScroller;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判定为拖动的最小移动像素数</span><br><span class="line">     */</span><br><span class="line">    private int mTouchSlop;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 手机按下时的屏幕坐标</span><br><span class="line">     */</span><br><span class="line">    private float mXDown;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 手机当时所处的屏幕坐标</span><br><span class="line">     */</span><br><span class="line">    private float mXMove;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 上次触发ACTION_MOVE事件时的屏幕坐标</span><br><span class="line">     */</span><br><span class="line">    private float mXLastMove;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 界面可滚动的左边界</span><br><span class="line">     */</span><br><span class="line">    private int leftBorder;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 界面可滚动的右边界</span><br><span class="line">     */</span><br><span class="line">    private int rightBorder;</span><br><span class="line">    /**</span><br><span class="line">     * 页号,默认为0</span><br><span class="line">     */</span><br><span class="line">    private int targetIndex = 0;</span><br><span class="line"></span><br><span class="line">    private PageIndexListener mPageListener;</span><br><span class="line"></span><br><span class="line">    public ScrollerLinearLayout(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        // 第一步，创建Scroller的实例</span><br><span class="line">        mScroller = new Scroller(context);</span><br><span class="line">        ViewConfiguration configuration = ViewConfiguration.get(context);</span><br><span class="line">        // 获取TouchSlop值</span><br><span class="line">        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ScrollerLinearLayout(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        // 第一步，创建Scroller的实例</span><br><span class="line">        mScroller = new Scroller(context);</span><br><span class="line">        ViewConfiguration configuration = ViewConfiguration.get(context);</span><br><span class="line">        // 获取TouchSlop值</span><br><span class="line">        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ScrollerLinearLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        // 第一步，创建Scroller的实例</span><br><span class="line">        mScroller = new Scroller(context);</span><br><span class="line">        ViewConfiguration configuration = ViewConfiguration.get(context);</span><br><span class="line">        // 获取TouchSlop值</span><br><span class="line">        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">        super.onLayout(changed, l, t, r, b);</span><br><span class="line">        // 初始化左右边界值</span><br><span class="line">        leftBorder = getChildAt(0).getLeft();</span><br><span class="line">        rightBorder = getChildAt(getChildCount() - 1).getRight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        switch (ev.getAction()) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                mXDown = ev.getRawX();</span><br><span class="line">                mXLastMove = mXDown;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                mXMove = ev.getRawX();</span><br><span class="line">                float diff = Math.abs(mXMove - mXDown);</span><br><span class="line">                mXLastMove = mXMove;</span><br><span class="line">                // 当手指拖动值大于TouchSlop值时，认为应该进行滚动，拦截子控件的事件</span><br><span class="line">                if (diff &gt; mTouchSlop) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onInterceptTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line"></span><br><span class="line">        switch (event.getAction()) &#123;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                mXMove = event.getRawX();</span><br><span class="line">                int scrolledX = (int) (mXLastMove - mXMove);</span><br><span class="line">                if (getScrollX() + scrolledX &lt; leftBorder) &#123;</span><br><span class="line">                    scrollTo(leftBorder, 0);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else if (getScrollX() + 2 * getChildAt(0).getWidth() + scrolledX &gt; rightBorder) &#123;</span><br><span class="line">                    scrollTo(rightBorder - 2 * getChildAt(0).getWidth(), 0);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                scrollBy(scrolledX, 0);</span><br><span class="line">                mXLastMove = mXMove;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_UP:</span><br><span class="line">                int move = (int) (mXLastMove - mXMove);</span><br><span class="line">                // 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个界面</span><br><span class="line">                int scrollx = getScrollX();</span><br><span class="line">                if (targetIndex == 1 &amp;&amp; (getWidth() - scrollx) &gt; 0.2 * getWidth()) &#123;</span><br><span class="line">                    mScroller.startScroll(scrollx, 0, -scrollx, 0);</span><br><span class="line">                    invalidate();</span><br><span class="line">                    targetIndex = 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    targetIndex = (int) (scrollx + 0.8 * getWidth()) / getWidth();</span><br><span class="line">                    int dx = targetIndex * getWidth() - scrollx;</span><br><span class="line">                    // 第二步，调用startScroll()方法来初始化滚动数据并刷新界面</span><br><span class="line">                    mScroller.startScroll(scrollx, 0, dx, 0);</span><br><span class="line">                    invalidate();</span><br><span class="line">                &#125;</span><br><span class="line">                if (mPageListener != null) &#123;</span><br><span class="line">                    mPageListener.onPage(targetIndex);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 滑动到第几页</span><br><span class="line">     *</span><br><span class="line">     * @param index 页号</span><br><span class="line">     */</span><br><span class="line">    public void scrollToIndex(int index) &#123;</span><br><span class="line">        if (index == 0) &#123;</span><br><span class="line">            mScroller.startScroll(getScrollX(), 0, -getScrollX(), 0);</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125; else if (index == 1) &#123;</span><br><span class="line">            mScroller.startScroll(getScrollX(), 0, getWidth() - getScrollX(), 0);</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">        if (mPageListener != null) &#123;</span><br><span class="line">            mPageListener.onPage(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void computeScroll() &#123;</span><br><span class="line">        // 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑</span><br><span class="line">        if (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public interface PageIndexListener &#123;</span><br><span class="line">        void onPage(int index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setmPageListener(PageIndexListener mPageListener) &#123;</span><br><span class="line">        this.mPageListener = mPageListener;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原来的项目主页就是一个LinearLayout,一共放了4个Item,现在的元素越来越多,一个屏幕已经放不下了,现在需要滑动翻页.为了能达到这个效果,把LinearLayout替换成Viewpager，这是一个可行的方案。但是对项目代码侵入性太大，需要重写很多逻辑。我想达到
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Glide解惑之如何管理生命周期</title>
    <link href="http://yoursite.com/2019/03/15/Glide%E8%A7%A3%E6%83%91%E4%B9%8B%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/03/15/Glide解惑之如何管理生命周期/</id>
    <published>2019-03-15T07:47:28.000Z</published>
    <updated>2019-03-15T08:52:11.009Z</updated>
    
    <content type="html"><![CDATA[<p>本人在使用Glide图片下载框架的时候,一直有一个疑惑,它到底是怎么做到Context在Destory的时候自动停止下载请求的,带着好奇心的驱使我去了解了下源码,心里大概知道了真相.</p><p>一般我们要下载图片，Glide是这样做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context).load(url).into(imageview);</span><br></pre></td></tr></table></figure><p>非常简洁精炼的用法,但是内部却做了大量的工作,下面一步一步来分析。</p><p>首先Glide.with返回了一个RequestManager,进入源码代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static RequestManager with(FragmentActivity activity) &#123;</span><br><span class="line">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">    return retriever.get(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据RequestManagerRetriever获取RequestManager.那RequestManagerRetriever.get又做了什么工作呢？继续往下看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public RequestManager get(FragmentActivity activity) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        return get(activity.getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        assertNotDestroyed(activity);</span><br><span class="line">        FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">        return supportFragmentGet(activity, fm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到如果不在后台线程会调用supportFragmentGet(activity, fm)，我们继续看supportFragmentGet方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RequestManager supportFragmentGet(Context context, FragmentManager fm) &#123;</span><br><span class="line">    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    if (requestManager == null) &#123;</span><br><span class="line">        requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">        current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    return requestManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看这个getSupportRequestManagerFragment里面做了什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SupportRequestManagerFragment getSupportRequestManagerFragment(final FragmentManager fm) &#123;</span><br><span class="line">    SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        FRAGMENT_TAG);</span><br><span class="line">    if (current == null) &#123;</span><br><span class="line">        current = pendingSupportRequestManagerFragments.get(fm);</span><br><span class="line">        if (current == null) &#123;</span><br><span class="line">            current = new SupportRequestManagerFragment();</span><br><span class="line">            pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class="line">            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">            handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK,重点来了,我们定位到fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();看见没，这段代码的意思是向Activity state中添加一个Fragment，里面没有填具体的containerview,意思是不会添加进视图容器，但是会存在与当前的Activity state,而这个Fragment是SupportRequestMangerFragment。</p><p><strong>好,到目前为止,我们知道其实当调用Glide.with方法的时候传入的context,Glide都会为其添加一个没有containerview的Fragment,其实可以理解是一个没有界面的Fragment。</strong> </p><p>接下去看这个Fragment里面具体的工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onStop() &#123;</span><br><span class="line">    super.onStop();</span><br><span class="line">    lifecycle.onStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    lifecycle.onDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在生命周期的onStop和onDestroy分别调用了lifecycle方法,这里的lifecycle是ActivityFragmentLifecycle：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void onStop() &#123;</span><br><span class="line">    isStarted = false;</span><br><span class="line">    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">        lifecycleListener.onStop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onDestroy() &#123;</span><br><span class="line">    isDestroyed = true;</span><br><span class="line">    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">        lifecycleListener.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lifecycleListeners其实就是一个set对象,键是LifecycleListener.在生命周期改变的时候会遍历这个集合,调用LifecycleListener的stop和destroy方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final Set&lt;LifecycleListener&gt; lifecycleListeners =</span><br><span class="line">        Collections.newSetFromMap(new WeakHashMap&lt;LifecycleListener, Boolean&gt;());</span><br></pre></td></tr></table></figure><p>那它是在哪里进行数据更新的呢?它其实是在ActivityFragmentLifecycle里更新的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addListener(LifecycleListener listener) &#123;</span><br><span class="line">    lifecycleListeners.add(listener);</span><br><span class="line"></span><br><span class="line">    if (isDestroyed) &#123;</span><br><span class="line">        listener.onDestroy();</span><br><span class="line">    &#125; else if (isStarted) &#123;</span><br><span class="line">        listener.onStart();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        listener.onStop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码又会在RequestManager初始化的时候调用,在结合前面我们的分析结果,没错就是在Glide.with调用后就会调addListener方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ConnectivityMonitor connectivityMonitor = factory.build(context,</span><br><span class="line">        new RequestManagerConnectivityListener(requestTracker));</span><br><span class="line"></span><br><span class="line">// If we&apos;re the application level request manager, we may be created on a background thread. In that case we</span><br><span class="line">// cannot risk synchronously pausing or resuming requests, so we hack around the issue by delaying adding</span><br><span class="line">// ourselves as a lifecycle listener by posting to the main thread. This should be entirely safe.</span><br><span class="line">if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">    new Handler(Looper.getMainLooper()).post(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            lifecycle.addListener(RequestManager.this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    lifecycle.addListener(this);</span><br><span class="line">&#125;</span><br><span class="line">lifecycle.addListener(connectivityMonitor);</span><br></pre></td></tr></table></figure><p>上面是RequestManager初始化的代码一部分.RequestManager实现了LifecycleListener接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class RequestManager implements LifecycleListener &#123;</span><br></pre></td></tr></table></figure><p>它实现接口做的工作是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onStop() &#123;</span><br><span class="line">    pauseRequests();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Lifecycle callback that cancels all in progress requests and clears and recycles resources for all completed</span><br><span class="line"> * requests.</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void onDestroy() &#123;</span><br><span class="line">    requestTracker.clearRequests();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看注释和代码命名就大概能推测到在Stop和Destroy的时候会分别暂停和取消请求,到这里我们大概就知道了具体的实现逻辑了.</p><p><strong>总结一下:Glide.with的时候会为context添加一个空白的Fragment,通过监听Fragment的生命周期,会在每次发生改变的时候遍历LifecycleListener,其实也就是RequestManager,调用其onStop,onDestroy方法达到暂停和取消请求的目的.</strong></p><p>完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本人在使用Glide图片下载框架的时候,一直有一个疑惑,它到底是怎么做到Context在Destory的时候自动停止下载请求的,带着好奇心的驱使我去了解了下源码,心里大概知道了真相.&lt;/p&gt;
&lt;p&gt;一般我们要下载图片，Glide是这样做的：&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android AudioRecord音频录制实现暂停功能</title>
    <link href="http://yoursite.com/2019/03/13/Android%20AudioRecord%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%E5%AE%9E%E7%8E%B0%E6%9A%82%E5%81%9C%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2019/03/13/Android AudioRecord音频录制实现暂停功能/</id>
    <published>2019-03-13T09:58:45.000Z</published>
    <updated>2019-03-13T12:06:03.790Z</updated>
    
    <content type="html"><![CDATA[<p>AudioRecord官方API并没有实现音频暂停功能，Google了半天也没有找到具体的好的实现方法，所以我打算自己实现。先回顾一下音频开始录制的具体实现。</p><ol><li><p>首先先得初始化AudioRecord对象 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">audioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC, SAMPLE_RATE_INHZ,</span><br><span class="line">        CHANNEL_CONFIG, AUDIO_FORMAT, minBufferSize);</span><br></pre></td></tr></table></figure></li></ol><p>​       上面的参数具体指声道数,采样率以及最小缓冲区。</p><ol start="2"><li><p>新建文件用来存储录制的音频数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final File file = new File(getExternalFilesDir(Environment.DIRECTORY_MUSIC),</span><br><span class="line">        &quot;wenwenrecord.pcm&quot;);</span><br></pre></td></tr></table></figure></li><li><p>开启一个线程不断的往文件里面写数据</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    //往文件里面写数据</span><br><span class="line">    audioRecord.read(data, 0, minBufferSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p><strong>问题来了，官方只提供给了我们录制音频的接口，并没有提供暂停和停止的接口，该怎么实现呢？</strong></p><p>嗯，其实只要仔细想一下就知道了，我在上面开启了一个线程往文件里面写数据，只需要定义一个标志变量用来判断是否继续写入数据就行了。如果是暂停录制就不执行audioRecord.read，如果是停止录制就跳出while循环。具体实现如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        FileOutputStream os = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            os = new FileOutputStream(file);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (null != os) &#123;</span><br><span class="line">            while (currentAudioState.get() == PAUSE_STATE ||</span><br><span class="line">                    currentAudioState.get() == REDORDING_STATE) &#123;</span><br><span class="line">                if (currentAudioState.get() == PAUSE_STATE) &#123;</span><br><span class="line">                    LogUtil.i(&quot;Record&quot;, &quot;pause...&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    int read = audioRecord.read(data, 0, minBufferSize);</span><br><span class="line">                 </span><br><span class="line">                    if (AudioRecord.ERROR_INVALID_OPERATION != read) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            os.write(data);</span><br><span class="line">                        &#125; catch (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                LogUtil.i(TAG, &quot;run: close file output stream !&quot;);</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>这里的currentAudioState定义为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 当前录音状态</span><br><span class="line"> */</span><br><span class="line">private AtomicInteger currentAudioState = new AtomicInteger(STOP_STATE);</span><br></pre></td></tr></table></figure><p>为了保证在多线程环境下的原子操作我用了并发包里的AtomicInteger。</p><p>完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AudioRecord官方API并没有实现音频暂停功能，Google了半天也没有找到具体的好的实现方法，所以我打算自己实现。先回顾一下音频开始录制的具体实现。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先先得初始化AudioRecord对象 &lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
  </entry>
  
</feed>
