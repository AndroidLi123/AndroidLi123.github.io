<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WangCode&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-15T08:52:11.009Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WangCode</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Glide解惑之如何管理生命周期</title>
    <link href="http://yoursite.com/2019/03/15/Glide%E8%A7%A3%E6%83%91%E4%B9%8B%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/03/15/Glide解惑之如何管理生命周期/</id>
    <published>2019-03-15T07:47:28.000Z</published>
    <updated>2019-03-15T08:52:11.009Z</updated>
    
    <content type="html"><![CDATA[<p>本人在使用Glide图片下载框架的时候,一直有一个疑惑,它到底是怎么做到Context在Destory的时候自动停止下载请求的,带着好奇心的驱使我去了解了下源码,心里大概知道了真相.</p><p>一般我们要下载图片，Glide是这样做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context).load(url).into(imageview);</span><br></pre></td></tr></table></figure><p>非常简洁精炼的用法,但是内部却做了大量的工作,下面一步一步来分析。</p><p>首先Glide.with返回了一个RequestManager,进入源码代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static RequestManager with(FragmentActivity activity) &#123;</span><br><span class="line">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">    return retriever.get(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据RequestManagerRetriever获取RequestManager.那RequestManagerRetriever.get又做了什么工作呢？继续往下看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public RequestManager get(FragmentActivity activity) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        return get(activity.getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        assertNotDestroyed(activity);</span><br><span class="line">        FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">        return supportFragmentGet(activity, fm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到如果不在后台线程会调用supportFragmentGet(activity, fm)，我们继续看supportFragmentGet方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RequestManager supportFragmentGet(Context context, FragmentManager fm) &#123;</span><br><span class="line">    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    if (requestManager == null) &#123;</span><br><span class="line">        requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">        current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    return requestManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看这个getSupportRequestManagerFragment里面做了什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SupportRequestManagerFragment getSupportRequestManagerFragment(final FragmentManager fm) &#123;</span><br><span class="line">    SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        FRAGMENT_TAG);</span><br><span class="line">    if (current == null) &#123;</span><br><span class="line">        current = pendingSupportRequestManagerFragments.get(fm);</span><br><span class="line">        if (current == null) &#123;</span><br><span class="line">            current = new SupportRequestManagerFragment();</span><br><span class="line">            pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class="line">            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">            handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK,重点来了,我们定位到fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();看见没，这段代码的意思是向Activity state中添加一个Fragment，里面没有填具体的containerview,意思是不会添加进视图容器，但是会存在与当前的Activity state,而这个Fragment是SupportRequestMangerFragment。</p><p><strong>好,到目前为止,我们知道其实当调用Glide.with方法的时候传入的context,Glide都会为其添加一个没有containerview的Fragment,其实可以理解是一个没有界面的Fragment。</strong> </p><p>接下去看这个Fragment里面具体的工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onStop() &#123;</span><br><span class="line">    super.onStop();</span><br><span class="line">    lifecycle.onStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    lifecycle.onDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在生命周期的onStop和onDestroy分别调用了lifecycle方法,这里的lifecycle是ActivityFragmentLifecycle：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void onStop() &#123;</span><br><span class="line">    isStarted = false;</span><br><span class="line">    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">        lifecycleListener.onStop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onDestroy() &#123;</span><br><span class="line">    isDestroyed = true;</span><br><span class="line">    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">        lifecycleListener.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lifecycleListeners其实就是一个set对象,键是LifecycleListener.在生命周期改变的时候会遍历这个集合,调用LifecycleListener的stop和destroy方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final Set&lt;LifecycleListener&gt; lifecycleListeners =</span><br><span class="line">        Collections.newSetFromMap(new WeakHashMap&lt;LifecycleListener, Boolean&gt;());</span><br></pre></td></tr></table></figure><p>那它是在哪里进行数据更新的呢?它其实是在ActivityFragmentLifecycle里更新的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addListener(LifecycleListener listener) &#123;</span><br><span class="line">    lifecycleListeners.add(listener);</span><br><span class="line"></span><br><span class="line">    if (isDestroyed) &#123;</span><br><span class="line">        listener.onDestroy();</span><br><span class="line">    &#125; else if (isStarted) &#123;</span><br><span class="line">        listener.onStart();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        listener.onStop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码又会在RequestManager初始化的时候调用,在结合前面我们的分析结果,没错就是在Glide.with调用后就会调addListener方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ConnectivityMonitor connectivityMonitor = factory.build(context,</span><br><span class="line">        new RequestManagerConnectivityListener(requestTracker));</span><br><span class="line"></span><br><span class="line">// If we&apos;re the application level request manager, we may be created on a background thread. In that case we</span><br><span class="line">// cannot risk synchronously pausing or resuming requests, so we hack around the issue by delaying adding</span><br><span class="line">// ourselves as a lifecycle listener by posting to the main thread. This should be entirely safe.</span><br><span class="line">if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">    new Handler(Looper.getMainLooper()).post(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            lifecycle.addListener(RequestManager.this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    lifecycle.addListener(this);</span><br><span class="line">&#125;</span><br><span class="line">lifecycle.addListener(connectivityMonitor);</span><br></pre></td></tr></table></figure><p>上面是RequestManager初始化的代码一部分.RequestManager实现了LifecycleListener接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class RequestManager implements LifecycleListener &#123;</span><br></pre></td></tr></table></figure><p>它实现接口做的工作是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onStop() &#123;</span><br><span class="line">    pauseRequests();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Lifecycle callback that cancels all in progress requests and clears and recycles resources for all completed</span><br><span class="line"> * requests.</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void onDestroy() &#123;</span><br><span class="line">    requestTracker.clearRequests();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看注释和代码命名就大概能推测到在Stop和Destroy的时候会分别暂停和取消请求,到这里我们大概就知道了具体的实现逻辑了.</p><p><strong>总结一下:Glide.with的时候会为context添加一个空白的Fragment,通过监听Fragment的生命周期,会在每次发生改变的时候遍历LifecycleListener,其实也就是RequestManager,调用其onStop,onDestroy方法达到暂停和取消请求的目的.</strong></p><p>完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本人在使用Glide图片下载框架的时候,一直有一个疑惑,它到底是怎么做到Context在Destory的时候自动停止下载请求的,带着好奇心的驱使我去了解了下源码,心里大概知道了真相.&lt;/p&gt;
&lt;p&gt;一般我们要下载图片，Glide是这样做的：&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android AudioRecord音频录制实现暂停功能</title>
    <link href="http://yoursite.com/2019/03/13/Android%20AudioRecord%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%E5%AE%9E%E7%8E%B0%E6%9A%82%E5%81%9C%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2019/03/13/Android AudioRecord音频录制实现暂停功能/</id>
    <published>2019-03-13T09:58:45.000Z</published>
    <updated>2019-03-13T12:06:03.790Z</updated>
    
    <content type="html"><![CDATA[<p>AudioRecord官方API并没有实现音频暂停功能，Google了半天也没有找到具体的好的实现方法，所以我打算自己实现。先回顾一下音频开始录制的具体实现。</p><ol><li><p>首先先得初始化AudioRecord对象 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">audioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC, SAMPLE_RATE_INHZ,</span><br><span class="line">        CHANNEL_CONFIG, AUDIO_FORMAT, minBufferSize);</span><br></pre></td></tr></table></figure></li></ol><p>​       上面的参数具体指声道数,采样率以及最小缓冲区。</p><ol start="2"><li><p>新建文件用来存储录制的音频数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final File file = new File(getExternalFilesDir(Environment.DIRECTORY_MUSIC),</span><br><span class="line">        &quot;wenwenrecord.pcm&quot;);</span><br></pre></td></tr></table></figure></li><li><p>开启一个线程不断的往文件里面写数据</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    //往文件里面写数据</span><br><span class="line">    audioRecord.read(data, 0, minBufferSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p><strong>问题来了，官方只提供给了我们录制音频的接口，并没有提供暂停和停止的接口，该怎么实现呢？</strong></p><p>嗯，其实只要仔细想一下就知道了，我在上面开启了一个线程往文件里面写数据，只需要定义一个标志变量用来判断是否继续写入数据就行了。如果是暂停录制就不执行audioRecord.read，如果是停止录制就跳出while循环。具体实现如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        FileOutputStream os = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            os = new FileOutputStream(file);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (null != os) &#123;</span><br><span class="line">            while (currentAudioState.get() == PAUSE_STATE ||</span><br><span class="line">                    currentAudioState.get() == REDORDING_STATE) &#123;</span><br><span class="line">                if (currentAudioState.get() == PAUSE_STATE) &#123;</span><br><span class="line">                    LogUtil.i(&quot;Record&quot;, &quot;pause...&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    int read = audioRecord.read(data, 0, minBufferSize);</span><br><span class="line">                 </span><br><span class="line">                    if (AudioRecord.ERROR_INVALID_OPERATION != read) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            os.write(data);</span><br><span class="line">                        &#125; catch (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                LogUtil.i(TAG, &quot;run: close file output stream !&quot;);</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>这里的currentAudioState定义为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 当前录音状态</span><br><span class="line"> */</span><br><span class="line">private AtomicInteger currentAudioState = new AtomicInteger(STOP_STATE);</span><br></pre></td></tr></table></figure><p>为了保证在多线程环境下的原子操作我用了并发包里的AtomicInteger。</p><p>完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AudioRecord官方API并没有实现音频暂停功能，Google了半天也没有找到具体的好的实现方法，所以我打算自己实现。先回顾一下音频开始录制的具体实现。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先先得初始化AudioRecord对象 &lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/03/13/hello-world/"/>
    <id>http://yoursite.com/2019/03/13/hello-world/</id>
    <published>2019-03-13T09:41:05.080Z</published>
    <updated>2019-03-13T09:41:05.081Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
