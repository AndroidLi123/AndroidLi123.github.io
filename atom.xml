<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WangCode&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-21T10:47:15.497Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WangCode</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>卡拉OK歌词控件</title>
    <link href="http://yoursite.com/2020/01/21/%E5%8D%A1%E6%8B%89OK%E6%AD%8C%E8%AF%8D%E6%8E%A7%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/01/21/卡拉OK歌词控件/</id>
    <published>2020-01-21T07:38:26.000Z</published>
    <updated>2020-01-21T10:47:15.497Z</updated>
    
    <content type="html"><![CDATA[<p>最近时间闲暇，把卡拉OK项目再总结一下。</p><p>卡拉OK项目中，需要用到歌词逐亮效果，但是网上的效果都不太好，也不符合产品需求，所以我索性自己写了一个控件出来供大家分享。</p><p>看下效果</p><p><img src="/.com//karaok.gif" alt="6448b98fa20c4239bb7ce923eeb6c361"></p><p>两个问题点：</p><p>1.怎么实现逐亮歌词效果</p><p>2.怎么解析歌词</p><p>咱们先来解决第一个问题，怎么逐亮歌词。</p><p>刚开始我准备用LinearGradient来做，但是我试了下，效果不行，因为lineargradient有一个颜色过渡效果，</p><p>所以呈现效果会有霓虹灯似的颜色，与逐亮效果不符合，这个方案放弃掉。后来又想到图层混合模式PorterDuffXfermode中的DST_IN,还有一种干脆就是直接覆盖原来的绘制，实现逐亮效果。后来我打算用直接覆盖的方式来实现。</p><p>大体思路：首先是先绘制正常的一行不带进度没有逐亮效果的歌词，然后用另一个Paint绘制逐亮效果的歌词，卡拉ok歌词一般都会给到一个字的持续时间(需要解析歌词得到),我们可以用ValuneAnimator从0到一个字的宽度的过度量，然后时间就是解析得到的这个字的持续时间，通过update方法拿到宽度后，再绘制另一种颜色的歌词，这样的话，逐亮效果就有了。</p><p>核心代码如下：</p><pre><code>    //动画更新    @Override    public void onAnimationUpdate(ValueAnimator animation) {    //取到最新的卡拉ok歌词宽度    karaokWith = (int) animation.getAnimatedValue();    if (karaokWith &lt;= 0) {        karaokWith = 1;    }    if (karaokWith &gt;= maxAnimateValue &amp;&amp; index &lt;= animationEntities.size() - 1) {        index++;        if (index &lt; animationEntities.size()) {            maxAnimateValue = (int) (wordWith * (index + 1));            mValueAnimator = ValueAnimator.ofInt(karaokWith,                    maxAnimateValue);            mValueAnimator.setDuration(animationEntities.get(index).getDuration());            mValueAnimator.addUpdateListener(this);            mValueAnimator.start();        }    }    if (index &gt; animationEntities.size() - 1) {        mPaint.setTextSize(40);        karaokWith = 1;        if (scrollView != null &amp;&amp; !isScroll) {            isScroll = true;        }    }    //更新画笔属性    titleWidth = (int) mPaint.measureText(mTitleName);    textBitmap = Bitmap.createBitmap(titleWidth, getMeasuredHeight(), Bitmap.Config.ARGB_8888);    textCanvas = new Canvas(textBitmap);    kBitmap = Bitmap.createBitmap(karaokWith, getMeasuredHeight(), Bitmap.Config.ARGB_8888);    kCanvas = new Canvas(kBitmap);    invalidate();}      @Override    protected void onDraw(Canvas canvas) {        fontMetrics = mPaint.getFontMetricsInt();        //文本绘制基线        int baseline = (targetRect.bottom + targetRect.top - fontMetrics.bottom -                 fontMetrics.top) / 2;        //绘制普通没有动画的歌词        textCanvas.drawText(mTitleName, 0, baseline, mPaint);        canvas.drawBitmap(textBitmap, (getMeasuredWidth() - titleWidth) / 2, 0, mPaint);        if (isStart) {            //绘制有逐亮效果的歌词            kCanvas.drawText(mTitleName, 0, baseline, mKarokPaint);            canvas.drawBitmap(kBitmap, (getMeasuredWidth() - titleWidth) / 2, 0, mKarokPaint);        }    }</code></pre><p>还有一点提一下，绘制文本的时候要正确计算baseline，如代码给出。这点就不详细展开了，自己去查，比较简单。</p><p>好了逐亮效果有了，那改怎么解析歌词呢，一般卡拉ok歌词是如下的形式：</p><table><thead><tr><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">[04:31.27]<1412>我<372>的<256>牵<294>挂 <268>我<262>的<251>渴<233>望 <248>直<271>至<248>以<242>后</242></248></271></248></233></251></262></268></294></256></372></1412></td></tr><tr><td style="text-align:left"></td></tr></tbody></table><p>最开头是这段歌词的开始演唱时间戳，后面跟着的是这个字的持续时间多长。</p><p>那么我们该怎么解析才合适呢？可以想到的是用正则表达式方法来匹配我们想要的数据格式。先解析开始时间，让然后解析一个字的持续时间，用正则匹配可以很快很方便的计算出来。</p><p>自动滚动我们加一个ScrollView,然后等到一行歌词动画完成自动下一行歌词等到开始演唱时间到了后开启逐亮动画</p><p>下面是封装的一个歌词控件代码：</p><p>public class KaraokScrollView extends FrameLayout {</p><pre><code>private ScrollView mScrollView;private LinearLayout mLinearLayout;private List&lt;CountDownTimer&gt; countDownTimers = new ArrayList&lt;&gt;();public KaraokScrollView(@NonNull Context context) {    super(context);    init();}public KaraokScrollView(@NonNull Context context, @Nullable AttributeSet attrs) {    super(context, attrs);    init();}public KaraokScrollView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {    super(context, attrs, defStyleAttr);    init();}private void init() {    inflate(getContext(),R.layout.layout_lyric,this);    mScrollView = findViewById(R.id.sl);    mLinearLayout = findViewById(R.id.ll_lyric);}public void setData(List&lt;LineLyricEntity&gt;entities) {    for(int i=0;i&lt;entities.size();i++) {        LineLyricEntity entity = entities.get(i);        DrawTextView drawTextView = new DrawTextView(getContext());        drawTextView.setmTitleSize(40);        drawTextView.setAnimationEntities(entity.getAnimationEntities());        drawTextView.setmTitleColor(R.color.design_default_color_primary_dark);        drawTextView.setScrollView(mScrollView);        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,                100);        params.gravity = Gravity.CENTER_HORIZONTAL;        drawTextView.setLayoutParams(params);        long time = entity.getStartTime();        CountDownTimer timer = new CountDownTimer(time, 10) {            @Override            public void onTick(long millisUntilFinished) {            }            @Override            public void onFinish() {                mScrollView.smoothScrollBy(0, 100);                drawTextView.startAnimation();            }        };        countDownTimers.add(timer);        mLinearLayout.addView(drawTextView);    }}public void scrollWith(int x,int y) {    mScrollView.smoothScrollBy(x,y);}public void startAnimation() {    for(int i=0;i&lt;countDownTimers.size();i++) {        CountDownTimer timer = countDownTimers.get(i);        timer.start();    }}</code></pre><p>}</p><p>完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近时间闲暇，把卡拉OK项目再总结一下。&lt;/p&gt;
&lt;p&gt;卡拉OK项目中，需要用到歌词逐亮效果，但是网上的效果都不太好，也不符合产品需求，所以我索性自己写了一个控件出来供大家分享。&lt;/p&gt;
&lt;p&gt;看下效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/.com//karaok.gif&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>FFmpeg音频解码以及用OpenSL ES播放</title>
    <link href="http://yoursite.com/2020/01/19/FFmpeg%E8%A7%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2020/01/19/FFmpeg解码/</id>
    <published>2020-01-19T08:56:04.000Z</published>
    <updated>2020-01-21T09:07:54.118Z</updated>
    
    <content type="html"><![CDATA[<p>因为项目需要,需要在Android用到FFmpeg来实现音频编解码以及用OpenSL ES实现C++层的音频播放功能。趁着最近时间空闲，把用到的知识点整理出来以供备用。</p><p>解码流程：</p><p>第一步  avformat_open_input:打开输入流</p><p>第二步  avcodec_find_decoder:查找解码器</p><p>第三步  avcodec_open2:打开解码器</p><p>第四步  av_read_frame:读取码流中的多个音频帧</p><p>第五步 avcodec_send_packet：发送数据到解码队列中</p><p>第六步 avcodec_receive_frame：从解码队列里取出音频帧  </p><p>第七步 swr_convert：重采样音频数据</p><p>最后释放指针资源av_packet_free</p><p>FFmpeg解码大体流程其实是固定的，可以写一个模板代码套用就可以。</p><p>但是有一个需要注意的点，我在这个点花费了好长时间才弄明白，就是重采样的时候，网上大多数都是在解码前就</p><p>从AVCodecContext里获取sample_rate,然后设置到重采样的初始化数据里，但是这样做有一个问题，有时候从AVCodecContext里获取的采样率是0！因为很多时候音频文件不是标准的音频文件，所以只能是在解码后从音频帧里面取出采样率才对，然后再重采样音频帧。伪代码就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">//初始化FormatContext</span><br><span class="line">    AVFormatContext *formatContext = avformat_alloc_context();</span><br><span class="line">    if (!formatContext) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打开输入流</span><br><span class="line">    retcode = avformat_open_input(&amp;formatContext, pamPath, nullptr, nullptr);</span><br><span class="line">    if (retcode != 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //读取媒体文件信息</span><br><span class="line">    retcode = avformat_find_stream_info(formatContext, NULL);</span><br><span class="line">    if (retcode != 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //分配codecContext</span><br><span class="line">    codecContext = avcodec_alloc_context3(NULL);</span><br><span class="line">    if (!codecContext) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //寻找到音频流的下标</span><br><span class="line">    audioIndex = av_find_best_stream(formatContext, AVMEDIA_TYPE_AUDIO, -1, -1, NULL, 0);</span><br><span class="line">codecContext-&gt;sample_rate</span><br><span class="line">    //将视频流的的编解码信息拷贝到codecContext中</span><br><span class="line">    retcode = avcodec_parameters_to_context(codecContext,</span><br><span class="line">                                            formatContext-&gt;streams[audioIndex]-&gt;codecpar);</span><br><span class="line">    if (retcode != 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找解码器</span><br><span class="line">    codec = avcodec_find_decoder(codecContext-&gt;codec_id);</span><br><span class="line">    if (codec == nullptr) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打开解码器</span><br><span class="line">    retcode = avcodec_open2(codecContext, codec, nullptr);</span><br><span class="line">    if (retcode != 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    /** ########## 获取实际音频的参数 ##########**/</span><br><span class="line">    //单个通道中的采样数</span><br><span class="line">    out_nb_samples = codecContext-&gt;frame_size;</span><br><span class="line">    //输出的声道数</span><br><span class="line">    out_channels = av_get_channel_layout_nb_channels(out_chn_layout);</span><br><span class="line">    //输出音频的布局</span><br><span class="line">    in_chn_layout = av_get_default_channel_layout(codecContext-&gt;channels);</span><br><span class="line"></span><br><span class="line">    /** 计算重采样后的实际数据大小,并分配空间 **/</span><br><span class="line"></span><br><span class="line">    //分配输出buffer的空间</span><br><span class="line">    outBuff = (unsigned char *) av_malloc(MAX_AUDIO_FRAME_SIZE * 2); //双声道</span><br><span class="line"></span><br><span class="line">    //循环读取packet并且解码</span><br><span class="line">    int sendcode = 0;</span><br><span class="line">    //初始化一个packet</span><br><span class="line">    AVPacket *packet = av_packet_alloc();</span><br><span class="line">    //初始化一个Frame</span><br><span class="line">    AVFrame *frame = av_frame_alloc();</span><br><span class="line">    while (av_read_frame(formatContext, packet) &gt;= 0) &#123;</span><br><span class="line">        if (packet-&gt;stream_index == audioIndex) &#123;</span><br><span class="line"></span><br><span class="line">            if (avcodec_send_packet(codecContext, packet) == 0) &#123;</span><br><span class="line">                //接受解码后的音频数据</span><br><span class="line">                while (avcodec_receive_frame(codecContext, frame) == 0) &#123;</span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">                    //初始化重采样器</span><br><span class="line">                    auConvertContext = swr_alloc_set_opts(NULL, AV_CH_LAYOUT_STEREO, out_sample_fmt,</span><br><span class="line">                                                          frame-&gt;sample_rate,</span><br><span class="line">                                                          AV_CH_LAYOUT_STEREO, AV_SAMPLE_FMT_S16,</span><br><span class="line">                                                          frame-&gt;sample_rate, 0,</span><br><span class="line">                                                          NULL);</span><br><span class="line">                    //初始化SwResample的Context</span><br><span class="line">                    swr_init(auConvertContext);</span><br><span class="line"></span><br><span class="line">                    int nb = swr_convert(auConvertContext, &amp;outBuff, MAX_AUDIO_FRAME_SIZE,</span><br><span class="line">                                         (const uint8_t **) frame-&gt;data,</span><br><span class="line">                                         frame-&gt;nb_samples);</span><br><span class="line"></span><br><span class="line">                    int out_channels = av_get_channel_layout_nb_channels(AV_CH_LAYOUT_STEREO);</span><br><span class="line">                    out_buffer_size =</span><br><span class="line">                            nb * out_channels *  av_get_bytes_per_sample(AV_SAMPLE_FMT_S16);</span><br><span class="line">                    fwrite(outBuff, 1, out_buffer_size, ff_accompany);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    av_packet_unref(packet);</span><br></pre></td></tr></table></figure><p>上面的代码把音频文件解码后的音频数据写入了文件，解码后的格式是原始音频格式PCM，那么如果想播放PCM格式音频的话，可以用AudioTrack,这是在JAVA层封装的播放PCM的对象，底层实现还是在c++,但是多了一次数据拷贝过程，如果想延迟尽可能低，可以考虑用OpenSL ES来实现。下面介绍OpenSL ES。</p><p>OpenSL ES是为了在C++层实现播放PCM格式音频的库，Android系统自带了集成的这个库，但是没有全部集成功能，只用了一部分，也就是阉割版本，但是对于播放音频来说已经足够了。</p><p>和解码一样，播放也比较简单，也都是一些模板代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">SLresult result;</span><br><span class="line"></span><br><span class="line">//第一步，创建引擎</span><br><span class="line">createEngine();</span><br><span class="line"></span><br><span class="line">//第二步，创建混音器</span><br><span class="line">const SLInterfaceID mids[1] = &#123;SL_IID_ENVIRONMENTALREVERB&#125;;</span><br><span class="line">const SLboolean mreq[1] = &#123;SL_BOOLEAN_FALSE&#125;;</span><br><span class="line">result = (*engineEngine)-&gt;CreateOutputMix(engineEngine, &amp;outputMixObject, 1, mids, mreq);</span><br><span class="line">(void) result;</span><br><span class="line">result = (*outputMixObject)-&gt;Realize(outputMixObject, SL_BOOLEAN_FALSE);</span><br><span class="line">(void) result;</span><br><span class="line">result = (*outputMixObject)-&gt;GetInterface(outputMixObject, SL_IID_ENVIRONMENTALREVERB,</span><br><span class="line">                                          &amp;outputMixEnvironmentalReverb);</span><br><span class="line"></span><br><span class="line">if (SL_RESULT_SUCCESS == result) &#123;</span><br><span class="line">    result = (*outputMixEnvironmentalReverb)-&gt;SetEnvironmentalReverbProperties(</span><br><span class="line">            outputMixEnvironmentalReverb, &amp;reverbSettings);</span><br><span class="line">    (void) result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SLDataLocator_OutputMix outputMix = &#123;SL_DATALOCATOR_OUTPUTMIX, outputMixObject&#125;;</span><br><span class="line"></span><br><span class="line">SLDataSink audioSnk = &#123;&amp;outputMix, nullptr&#125;;</span><br><span class="line"></span><br><span class="line">// 第三步，配置PCM格式信息</span><br><span class="line">SLDataLocator_AndroidSimpleBufferQueue android_queue = &#123;</span><br><span class="line">        SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE,</span><br><span class="line">        2&#125;;</span><br><span class="line"></span><br><span class="line">SLDataFormat_PCM pcm = &#123;</span><br><span class="line">        SL_DATAFORMAT_PCM,//播放pcm格式的数据</span><br><span class="line">        (SLuint32) 2,//2个声道（立体声）</span><br><span class="line">        SL_SAMPLINGRATE_16,</span><br><span class="line">        SL_PCMSAMPLEFORMAT_FIXED_16,//位数 16位</span><br><span class="line">        SL_PCMSAMPLEFORMAT_FIXED_16,//和位数一致就行</span><br><span class="line">        SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT,//立体声（前左前右）</span><br><span class="line">        SL_BYTEORDER_LITTLEENDIAN//结束标志</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SLDataSource slDataSource = &#123;&amp;android_queue, &amp;pcm&#125;;</span><br><span class="line"></span><br><span class="line">const SLInterfaceID ids[4] = &#123;SL_IID_BUFFERQUEUE, SL_IID_VOLUME, SL_IID_PLAYBACKRATE, SL_IID_MUTESOLO&#125;;</span><br><span class="line"></span><br><span class="line">const SLboolean req[4] = &#123;SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE&#125;;</span><br><span class="line"></span><br><span class="line">(*engineEngine)-&gt;CreateAudioPlayer(engineEngine, &amp;pcmPlayerObject, &amp;slDataSource,</span><br><span class="line">                                   &amp;audioSnk, 4, ids, req);</span><br><span class="line"></span><br><span class="line">//初始化播放器</span><br><span class="line">(*pcmPlayerObject)-&gt;Realize(pcmPlayerObject, SL_BOOLEAN_FALSE);</span><br><span class="line"></span><br><span class="line">//得到接口后调用  获取Player接口</span><br><span class="line">(*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_PLAY, &amp;pcmPlayerPlay);</span><br><span class="line"></span><br><span class="line">//注册回调缓冲区 获取缓冲队列接口</span><br><span class="line">(*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_BUFFERQUEUE, &amp;pcmBufferQueue);</span><br><span class="line"></span><br><span class="line">//缓冲接口回调</span><br><span class="line">(*pcmBufferQueue)-&gt;RegisterCallback(pcmBufferQueue, byteCallBack, nullptr);</span><br><span class="line"></span><br><span class="line">//获取音量接口</span><br><span class="line">(*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_VOLUME, &amp;pcmPlayerVolume);</span><br><span class="line"></span><br><span class="line">//获取播放状态接口</span><br><span class="line">(*pcmPlayerPlay)-&gt;SetPlayState(pcmPlayerPlay, SL_PLAYSTATE_PLAYING);</span><br><span class="line">float nvolume = 1.0f;</span><br><span class="line"></span><br><span class="line">SLmillibel MinVolume = SL_MILLIBEL_MIN;</span><br><span class="line">SLmillibel MaxVolume = SL_MILLIBEL_MIN;</span><br><span class="line"></span><br><span class="line">(*pcmPlayerVolume)-&gt;GetMaxVolumeLevel(pcmPlayerVolume, &amp;MaxVolume);</span><br><span class="line">SLmillibel Volume = MinVolume + (SLmillibel)(((float)(MaxVolume - MinVolume))*nvolume);</span><br><span class="line"></span><br><span class="line">(*pcmPlayerVolume)-&gt;SetVolumeLevel(pcmPlayerVolume, Volume);</span><br><span class="line">//显示回调接口开始播放</span><br><span class="line">byteCallBack(pcmBufferQueue, nullptr);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void byteCallBack(SLAndroidSimpleBufferQueueItf bf, void *context) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SLAndroidSimpleBufferQueueState slState = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    (*pcmBufferQueue)-&gt;GetState(pcmBufferQueue, &amp;slState);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex_kara);</span><br><span class="line"></span><br><span class="line">    if (!queueChar.empty()) &#123;</span><br><span class="line"></span><br><span class="line">        char *buffer = queueChar.front();</span><br><span class="line"></span><br><span class="line">        queueChar.pop();</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex_kara);</span><br><span class="line"></span><br><span class="line">        (*pcmBufferQueue)-&gt;Enqueue(pcmBufferQueue,</span><br><span class="line">                                   buffer, (SLuint32)UDP_LEN);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex_kara);</span><br><span class="line"></span><br><span class="line">        pthread_cond_signal(&amp;cond_kara);</span><br><span class="line"></span><br><span class="line">        (*pcmBufferQueue)-&gt;Enqueue(pcmBufferQueue,</span><br><span class="line">                                   &quot;&quot;, 1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点，在播放回调函数里，我们从解码数据队列取出数据，然后Enqueue数据播放，没有数据就Enqueue空数据让其继续回调bytecallback函数，不然的话回调函数就停止回调了，播放也就停止了。</p><p>还有就是队列数据不能太多，容易造成噪音现象，我的猜测是当数据过多后，队列后一部分的数据可能先于前一部分的数据消费播放出来造成的。所以可以用C++的信号量机制来同步限制消费数据，我的实验结果是一般size大于5就锁住队列等待了，等队列小于5再进队列。</p><p>我现在的做法是一个线程做解码，一个线程播放，然后通过公用资源队列并用信号量机制来达到控制消费从而实现播放。</p><p>完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为项目需要,需要在Android用到FFmpeg来实现音频编解码以及用OpenSL ES实现C++层的音频播放功能。趁着最近时间空闲，把用到的知识点整理出来以供备用。&lt;/p&gt;
&lt;p&gt;解码流程：&lt;/p&gt;
&lt;p&gt;第一步  avformat_open_input:打开输入流&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OpenGL ES Lesson 1</title>
    <link href="http://yoursite.com/2019/06/12/OpenGL-ES-Lesson-1/"/>
    <id>http://yoursite.com/2019/06/12/OpenGL-ES-Lesson-1/</id>
    <published>2019-06-12T06:36:49.000Z</published>
    <updated>2019-06-12T07:25:59.190Z</updated>
    
    <content type="html"><![CDATA[<p>本文目的在此记录学习OpenGL ES的心得.</p><p>我大致整理了一下入门OpenGL必须理解并掌握的知识点，如果没有这些知识点的积累，我觉得很难去下手学习OpenGL. </p><p>一. 渲染的基本流程</p><p><img src="https://learnopengl-cn.readthedocs.io/zh/latest/img/01/04/pipeline.png" alt="img"></p><p>可以从上图看出，我们可以简单的把顶点着色器理解为定义形状,片段着色器是渲染颜色的。</p><p>二. 坐标的变换</p><p><img src="http://zhangtielei.com/assets/photos_opengl_trans/part1/coordinate_system_overview.png" alt="åæ åæ¢æ¦è§å¾"></p><p>我们需要把本地坐标变换为屏幕坐标，也就是2D坐标。</p><p>三.Shader编程</p><p>着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。我们必须学会Shader编程,才说入门了OpenGL.</p><p>下面我用一个画三角形的经典例子来把上述的3个重要知识点串联起来过一遍,详细知识点会再接下来的博文中一一讲诉。</p><p>在Android中,我们用GLSurfaceView显示OpenGL ES画的图形.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mGLSurfaceView.setRenderer(new LessonOneRenderer());</span><br></pre></td></tr></table></figure><p>重点是LessonOneRenderer类,这个类通过实现Render接口来做操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final String vertexShader =</span><br><span class="line">   &quot;uniform mat4 u_MVPMatrix;      \n&quot;       // A constant representing the combined model/view/projection matrix.</span><br><span class="line">   </span><br><span class="line">  + &quot;attribute vec4 a_Position;     \n&quot;       // Per-vertex position information we will pass in.</span><br><span class="line">  + &quot;attribute vec4 a_Color;        \n&quot;       // Per-vertex color information we will pass in.           </span><br><span class="line">  </span><br><span class="line">  + &quot;varying vec4 v_Color;          \n&quot;       // This will be passed into the fragment shader.</span><br><span class="line">  </span><br><span class="line">  + &quot;void main()                    \n&quot;       // The entry point for our vertex shader.</span><br><span class="line">  + &quot;&#123;                              \n&quot;</span><br><span class="line">  + &quot;   v_Color = a_Color;          \n&quot;       // Pass the color through to the fragment shader. </span><br><span class="line">                                 // It will be interpolated across the triangle.</span><br><span class="line">  + &quot;   gl_Position = u_MVPMatrix   \n&quot;    // gl_Position is a special variable used to store the final position.</span><br><span class="line">  + &quot;               * a_Position;   \n&quot;     // Multiply the vertex by the matrix to get the final point in                                                                 </span><br><span class="line">  + &quot;&#125;                              \n&quot;;    // normalized screen coordinates.</span><br></pre></td></tr></table></figure><p>我们首先定义了一个顶点着色器,gl_Position = u_MVPMatrix*a_Position,这段代码的意思是通过坐标变换,转为屏幕坐标,也就是经过一系列的model,view,projection.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final String fragmentShader =</span><br><span class="line">   &quot;precision mediump float;       \n&quot;       // Set the default precision to medium. We don&apos;t need as high of a </span><br><span class="line">                                 // precision in the fragment shader.            </span><br><span class="line">  + &quot;varying vec4 v_Color;          \n&quot;       // This is the color from the vertex shader interpolated across the </span><br><span class="line">                                 // triangle per fragment.          </span><br><span class="line">  + &quot;void main()                    \n&quot;       // The entry point for our fragment shader.</span><br><span class="line">  + &quot;&#123;                              \n&quot;</span><br><span class="line">  + &quot;   gl_FragColor = v_Color;     \n&quot;       // Pass the color directly through the pipeline.        </span><br><span class="line">  + &quot;&#125;                              \n&quot;;</span><br></pre></td></tr></table></figure><p>此片段着色器就是通过顶点着色器传过来的v_color赋值给gl_FragColor.</p><p>接下来其实就是模板代码,我觉得可以抽象出一个类来做.不过现在为了理解流程，就没有抽象出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Load in the vertex shader.</span><br><span class="line">int vertexShaderHandle = GLES20.glCreateShader(GLES20.GL_VERTEX_SHADER);</span><br><span class="line"></span><br><span class="line">if (vertexShaderHandle != 0) </span><br><span class="line">&#123;</span><br><span class="line">   // Pass in the shader source.</span><br><span class="line">   GLES20.glShaderSource(vertexShaderHandle, vertexShader);</span><br><span class="line"></span><br><span class="line">   // Compile the shader.</span><br><span class="line">   GLES20.glCompileShader(vertexShaderHandle);</span><br><span class="line"></span><br><span class="line">   // Get the compilation status.</span><br><span class="line">   final int[] compileStatus = new int[1];</span><br><span class="line">   GLES20.glGetShaderiv(vertexShaderHandle, GLES20.GL_COMPILE_STATUS, compileStatus, 0);</span><br><span class="line"></span><br><span class="line">   // If the compilation failed, delete the shader.</span><br><span class="line">   if (compileStatus[0] == 0) </span><br><span class="line">   &#123;           </span><br><span class="line">      GLES20.glDeleteShader(vertexShaderHandle);</span><br><span class="line">      vertexShaderHandle = 0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是编译，连接上面的着色器语言。片段着色器类似，就不贴了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// Create a program object and store the handle to it.</span><br><span class="line">int programHandle = GLES20.glCreateProgram();</span><br><span class="line"></span><br><span class="line">if (programHandle != 0) </span><br><span class="line">&#123;</span><br><span class="line">   // Bind the vertex shader to the program.</span><br><span class="line">   GLES20.glAttachShader(programHandle, vertexShaderHandle);        </span><br><span class="line"></span><br><span class="line">   // Bind the fragment shader to the program.</span><br><span class="line">   GLES20.glAttachShader(programHandle, fragmentShaderHandle);</span><br><span class="line">   </span><br><span class="line">   // Bind attributes</span><br><span class="line">   GLES20.glBindAttribLocation(programHandle, 0, &quot;a_Position&quot;);</span><br><span class="line">   GLES20.glBindAttribLocation(programHandle, 1, &quot;a_Color&quot;);</span><br><span class="line">   </span><br><span class="line">   // Link the two shaders together into a program.</span><br><span class="line">   GLES20.glLinkProgram(programHandle);</span><br><span class="line"></span><br><span class="line">   // Get the link status.</span><br><span class="line">   final int[] linkStatus = new int[1];</span><br><span class="line">   GLES20.glGetProgramiv(programHandle, GLES20.GL_LINK_STATUS, linkStatus, 0);</span><br><span class="line"></span><br><span class="line">   // If the link failed, delete the program.</span><br><span class="line">   if (linkStatus[0] == 0) </span><br><span class="line">   &#123;           </span><br><span class="line">      GLES20.glDeleteProgram(programHandle);</span><br><span class="line">      programHandle = 0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">  // Tell OpenGL to use this program when rendering.</span><br><span class="line">        GLES20.glUseProgram(programHandle);</span><br></pre></td></tr></table></figure><p>最后就是通过programHandle通知GLES使用。</p><p>然后我们在onDrawFrame方法里画三角形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void drawTriangle(final FloatBuffer aTriangleBuffer)</span><br><span class="line">&#123;</span><br><span class="line">   // Pass in the position information</span><br><span class="line">   aTriangleBuffer.position(mPositionOffset);</span><br><span class="line">       GLES20.glVertexAttribPointer(mPositionHandle, mPositionDataSize, GLES20.GL_FLOAT, false,</span><br><span class="line">              mStrideBytes, aTriangleBuffer);        </span><br><span class="line">               </span><br><span class="line">       GLES20.glEnableVertexAttribArray(mPositionHandle);        </span><br><span class="line">       </span><br><span class="line">       // Pass in the color information</span><br><span class="line">       aTriangleBuffer.position(mColorOffset);</span><br><span class="line">       GLES20.glVertexAttribPointer(mColorHandle, mColorDataSize, GLES20.GL_FLOAT, false,</span><br><span class="line">              mStrideBytes, aTriangleBuffer);</span><br><span class="line">       </span><br><span class="line">       GLES20.glEnableVertexAttribArray(mColorHandle);</span><br><span class="line">       </span><br><span class="line">   // This multiplies the view matrix by the model matrix, and stores the result in the MVP matrix</span><br><span class="line">       // (which currently contains model * view).</span><br><span class="line">       Matrix.multiplyMM(mMVPMatrix, 0, mViewMatrix, 0, mModelMatrix, 0);</span><br><span class="line">       </span><br><span class="line">       // This multiplies the modelview matrix by the projection matrix, and stores the result in the MVP matrix</span><br><span class="line">       // (which now contains model * view * projection).</span><br><span class="line">       Matrix.multiplyMM(mMVPMatrix, 0,  mMVPMatrix, 0, mProjectionMatrix, 0);</span><br><span class="line"></span><br><span class="line">       GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mMVPMatrix, 0);</span><br><span class="line">       GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, 3);                               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先设置了缓冲区的位置偏移，然后把数据提供给了顶点着色器。最后经过矩阵变换把坐标投影到屏幕上了。</p><p><code>GLES20.glUniformMatrix4fv()</code>方法将最终的矩阵传入顶点着色器。<br><code>GLES20.glDrawArrays()</code>将我们的点转换为三角形并将其绘制在屏幕上。</p><p>这是截图</p><p><img src="https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/learn-opengl/20190122233309.png" alt="screenshot"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文目的在此记录学习OpenGL ES的心得.&lt;/p&gt;
&lt;p&gt;我大致整理了一下入门OpenGL必须理解并掌握的知识点，如果没有这些知识点的积累，我觉得很难去下手学习OpenGL. &lt;/p&gt;
&lt;p&gt;一. 渲染的基本流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lea
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为LinearLayout加入滑动以及分页效果</title>
    <link href="http://yoursite.com/2019/04/09/%E4%B8%BALinearLayout%E5%8A%A0%E5%85%A5%E6%BB%91%E5%8A%A8%E4%BB%A5%E5%8F%8A%E5%88%86%E9%A1%B5%E6%95%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2019/04/09/为LinearLayout加入滑动以及分页效果/</id>
    <published>2019-04-09T07:06:23.000Z</published>
    <updated>2019-04-10T09:00:32.827Z</updated>
    
    <content type="html"><![CDATA[<p>原来的项目主页就是一个LinearLayout,一共放了4个Item,现在的元素越来越多,一个屏幕已经放不下了,现在需要滑动翻页.为了能达到这个效果,把LinearLayout替换成Viewpager，这是一个可行的方案。但是对项目代码侵入性太大，需要重写很多逻辑。我想达到的效果是继续沿用原来的代码逻辑，后面如果增加了一个Item,只需在布局里面增加一个Item就可以了，什么也不用做。这样即实现了需求，代码又不用改多少。达到低侵入性的效果。</p><p>为了达到我的要求，只需使LinearLayout具备滑动功能即可,用Scroller这个类就能控制滑动。</p><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取TouchSlop值</span><br><span class="line">mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);</span><br></pre></td></tr></table></figure></li></ol><p>滑动像素超过上面的ToushSlop值就会判定为滑动，不然的话手点一下也会出现滑动，体验不好。</p><ol start="2"><li><p>重写onInterceptTouchEvent拦截事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    switch (ev.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            mXDown = ev.getRawX();</span><br><span class="line">            mXLastMove = mXDown;</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_MOVE:</span><br><span class="line">            mXMove = ev.getRawX();</span><br><span class="line">            float diff = Math.abs(mXMove - mXDown);</span><br><span class="line">            mXLastMove = mXMove;</span><br><span class="line">            // 当手指拖动值大于TouchSlop值时，认为应该进行滚动，拦截子控件的事件</span><br><span class="line">            if (diff &gt; mTouchSlop) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onInterceptTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在onTouchEvent方法里处理拦截事件,当滑动屏幕超过20%的时候,就调用scoller.startScroll方法进行滑动.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">case MotionEvent.ACTION_UP:</span><br><span class="line">    int move = (int) (mXLastMove - mXMove);</span><br><span class="line">    // 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个界面</span><br><span class="line">    int scrollx = getScrollX();</span><br><span class="line">    if (targetIndex == 1 &amp;&amp; (getWidth() - scrollx) &gt; 0.2 * getWidth()) &#123;</span><br><span class="line">        mScroller.startScroll(scrollx, 0, -scrollx, 0);</span><br><span class="line">        invalidate();</span><br><span class="line">        targetIndex = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        targetIndex = (int) (scrollx + 0.8 * getWidth()) / getWidth();</span><br><span class="line">        int dx = targetIndex * getWidth() - scrollx;</span><br><span class="line">        // 第二步，调用startScroll()方法来初始化滚动数据并刷新界面</span><br><span class="line">        mScroller.startScroll(scrollx, 0, dx, 0);</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    if (mPageListener != null) &#123;</span><br><span class="line">        mPageListener.onPage(targetIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure></li><li><p>最后重写computeScroll()方法</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void computeScroll() &#123;</span><br><span class="line">    // 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑</span><br><span class="line">    if (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author:xiaowang.li</span><br><span class="line"> * Date:26/03/2019</span><br><span class="line"> * Description:支持类似ViewPager的LineaLayout,通用性不好,以后来完善</span><br><span class="line"> */</span><br><span class="line">public class ScrollerLinearLayout extends LinearLayout &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 用于完成滚动操作的实例</span><br><span class="line">     */</span><br><span class="line">    private Scroller mScroller;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判定为拖动的最小移动像素数</span><br><span class="line">     */</span><br><span class="line">    private int mTouchSlop;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 手机按下时的屏幕坐标</span><br><span class="line">     */</span><br><span class="line">    private float mXDown;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 手机当时所处的屏幕坐标</span><br><span class="line">     */</span><br><span class="line">    private float mXMove;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 上次触发ACTION_MOVE事件时的屏幕坐标</span><br><span class="line">     */</span><br><span class="line">    private float mXLastMove;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 界面可滚动的左边界</span><br><span class="line">     */</span><br><span class="line">    private int leftBorder;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 界面可滚动的右边界</span><br><span class="line">     */</span><br><span class="line">    private int rightBorder;</span><br><span class="line">    /**</span><br><span class="line">     * 页号,默认为0</span><br><span class="line">     */</span><br><span class="line">    private int targetIndex = 0;</span><br><span class="line"></span><br><span class="line">    private PageIndexListener mPageListener;</span><br><span class="line"></span><br><span class="line">    public ScrollerLinearLayout(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        // 第一步，创建Scroller的实例</span><br><span class="line">        mScroller = new Scroller(context);</span><br><span class="line">        ViewConfiguration configuration = ViewConfiguration.get(context);</span><br><span class="line">        // 获取TouchSlop值</span><br><span class="line">        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ScrollerLinearLayout(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        // 第一步，创建Scroller的实例</span><br><span class="line">        mScroller = new Scroller(context);</span><br><span class="line">        ViewConfiguration configuration = ViewConfiguration.get(context);</span><br><span class="line">        // 获取TouchSlop值</span><br><span class="line">        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ScrollerLinearLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        // 第一步，创建Scroller的实例</span><br><span class="line">        mScroller = new Scroller(context);</span><br><span class="line">        ViewConfiguration configuration = ViewConfiguration.get(context);</span><br><span class="line">        // 获取TouchSlop值</span><br><span class="line">        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">        super.onLayout(changed, l, t, r, b);</span><br><span class="line">        // 初始化左右边界值</span><br><span class="line">        leftBorder = getChildAt(0).getLeft();</span><br><span class="line">        rightBorder = getChildAt(getChildCount() - 1).getRight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        switch (ev.getAction()) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                mXDown = ev.getRawX();</span><br><span class="line">                mXLastMove = mXDown;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                mXMove = ev.getRawX();</span><br><span class="line">                float diff = Math.abs(mXMove - mXDown);</span><br><span class="line">                mXLastMove = mXMove;</span><br><span class="line">                // 当手指拖动值大于TouchSlop值时，认为应该进行滚动，拦截子控件的事件</span><br><span class="line">                if (diff &gt; mTouchSlop) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onInterceptTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line"></span><br><span class="line">        switch (event.getAction()) &#123;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                mXMove = event.getRawX();</span><br><span class="line">                int scrolledX = (int) (mXLastMove - mXMove);</span><br><span class="line">                if (getScrollX() + scrolledX &lt; leftBorder) &#123;</span><br><span class="line">                    scrollTo(leftBorder, 0);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else if (getScrollX() + 2 * getChildAt(0).getWidth() + scrolledX &gt; rightBorder) &#123;</span><br><span class="line">                    scrollTo(rightBorder - 2 * getChildAt(0).getWidth(), 0);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                scrollBy(scrolledX, 0);</span><br><span class="line">                mXLastMove = mXMove;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_UP:</span><br><span class="line">                int move = (int) (mXLastMove - mXMove);</span><br><span class="line">                // 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个界面</span><br><span class="line">                int scrollx = getScrollX();</span><br><span class="line">                if (targetIndex == 1 &amp;&amp; (getWidth() - scrollx) &gt; 0.2 * getWidth()) &#123;</span><br><span class="line">                    mScroller.startScroll(scrollx, 0, -scrollx, 0);</span><br><span class="line">                    invalidate();</span><br><span class="line">                    targetIndex = 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    targetIndex = (int) (scrollx + 0.8 * getWidth()) / getWidth();</span><br><span class="line">                    int dx = targetIndex * getWidth() - scrollx;</span><br><span class="line">                    // 第二步，调用startScroll()方法来初始化滚动数据并刷新界面</span><br><span class="line">                    mScroller.startScroll(scrollx, 0, dx, 0);</span><br><span class="line">                    invalidate();</span><br><span class="line">                &#125;</span><br><span class="line">                if (mPageListener != null) &#123;</span><br><span class="line">                    mPageListener.onPage(targetIndex);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 滑动到第几页</span><br><span class="line">     *</span><br><span class="line">     * @param index 页号</span><br><span class="line">     */</span><br><span class="line">    public void scrollToIndex(int index) &#123;</span><br><span class="line">        if (index == 0) &#123;</span><br><span class="line">            mScroller.startScroll(getScrollX(), 0, -getScrollX(), 0);</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125; else if (index == 1) &#123;</span><br><span class="line">            mScroller.startScroll(getScrollX(), 0, getWidth() - getScrollX(), 0);</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">        if (mPageListener != null) &#123;</span><br><span class="line">            mPageListener.onPage(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void computeScroll() &#123;</span><br><span class="line">        // 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑</span><br><span class="line">        if (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public interface PageIndexListener &#123;</span><br><span class="line">        void onPage(int index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setmPageListener(PageIndexListener mPageListener) &#123;</span><br><span class="line">        this.mPageListener = mPageListener;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原来的项目主页就是一个LinearLayout,一共放了4个Item,现在的元素越来越多,一个屏幕已经放不下了,现在需要滑动翻页.为了能达到这个效果,把LinearLayout替换成Viewpager，这是一个可行的方案。但是对项目代码侵入性太大，需要重写很多逻辑。我想达到
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Glide解惑之如何管理生命周期</title>
    <link href="http://yoursite.com/2019/03/15/Glide%E8%A7%A3%E6%83%91%E4%B9%8B%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/03/15/Glide解惑之如何管理生命周期/</id>
    <published>2019-03-15T07:47:28.000Z</published>
    <updated>2019-03-15T08:52:11.009Z</updated>
    
    <content type="html"><![CDATA[<p>本人在使用Glide图片下载框架的时候,一直有一个疑惑,它到底是怎么做到Context在Destory的时候自动停止下载请求的,带着好奇心的驱使我去了解了下源码,心里大概知道了真相.</p><p>一般我们要下载图片，Glide是这样做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context).load(url).into(imageview);</span><br></pre></td></tr></table></figure><p>非常简洁精炼的用法,但是内部却做了大量的工作,下面一步一步来分析。</p><p>首先Glide.with返回了一个RequestManager,进入源码代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static RequestManager with(FragmentActivity activity) &#123;</span><br><span class="line">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">    return retriever.get(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据RequestManagerRetriever获取RequestManager.那RequestManagerRetriever.get又做了什么工作呢？继续往下看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public RequestManager get(FragmentActivity activity) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        return get(activity.getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        assertNotDestroyed(activity);</span><br><span class="line">        FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">        return supportFragmentGet(activity, fm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到如果不在后台线程会调用supportFragmentGet(activity, fm)，我们继续看supportFragmentGet方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RequestManager supportFragmentGet(Context context, FragmentManager fm) &#123;</span><br><span class="line">    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    if (requestManager == null) &#123;</span><br><span class="line">        requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">        current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    return requestManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看这个getSupportRequestManagerFragment里面做了什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SupportRequestManagerFragment getSupportRequestManagerFragment(final FragmentManager fm) &#123;</span><br><span class="line">    SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        FRAGMENT_TAG);</span><br><span class="line">    if (current == null) &#123;</span><br><span class="line">        current = pendingSupportRequestManagerFragments.get(fm);</span><br><span class="line">        if (current == null) &#123;</span><br><span class="line">            current = new SupportRequestManagerFragment();</span><br><span class="line">            pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class="line">            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">            handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK,重点来了,我们定位到fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();看见没，这段代码的意思是向Activity state中添加一个Fragment，里面没有填具体的containerview,意思是不会添加进视图容器，但是会存在与当前的Activity state,而这个Fragment是SupportRequestMangerFragment。</p><p><strong>好,到目前为止,我们知道其实当调用Glide.with方法的时候传入的context,Glide都会为其添加一个没有containerview的Fragment,其实可以理解是一个没有界面的Fragment。</strong> </p><p>接下去看这个Fragment里面具体的工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onStop() &#123;</span><br><span class="line">    super.onStop();</span><br><span class="line">    lifecycle.onStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    lifecycle.onDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在生命周期的onStop和onDestroy分别调用了lifecycle方法,这里的lifecycle是ActivityFragmentLifecycle：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void onStop() &#123;</span><br><span class="line">    isStarted = false;</span><br><span class="line">    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">        lifecycleListener.onStop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onDestroy() &#123;</span><br><span class="line">    isDestroyed = true;</span><br><span class="line">    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">        lifecycleListener.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lifecycleListeners其实就是一个set对象,键是LifecycleListener.在生命周期改变的时候会遍历这个集合,调用LifecycleListener的stop和destroy方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final Set&lt;LifecycleListener&gt; lifecycleListeners =</span><br><span class="line">        Collections.newSetFromMap(new WeakHashMap&lt;LifecycleListener, Boolean&gt;());</span><br></pre></td></tr></table></figure><p>那它是在哪里进行数据更新的呢?它其实是在ActivityFragmentLifecycle里更新的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addListener(LifecycleListener listener) &#123;</span><br><span class="line">    lifecycleListeners.add(listener);</span><br><span class="line"></span><br><span class="line">    if (isDestroyed) &#123;</span><br><span class="line">        listener.onDestroy();</span><br><span class="line">    &#125; else if (isStarted) &#123;</span><br><span class="line">        listener.onStart();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        listener.onStop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码又会在RequestManager初始化的时候调用,在结合前面我们的分析结果,没错就是在Glide.with调用后就会调addListener方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ConnectivityMonitor connectivityMonitor = factory.build(context,</span><br><span class="line">        new RequestManagerConnectivityListener(requestTracker));</span><br><span class="line"></span><br><span class="line">// If we&apos;re the application level request manager, we may be created on a background thread. In that case we</span><br><span class="line">// cannot risk synchronously pausing or resuming requests, so we hack around the issue by delaying adding</span><br><span class="line">// ourselves as a lifecycle listener by posting to the main thread. This should be entirely safe.</span><br><span class="line">if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">    new Handler(Looper.getMainLooper()).post(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            lifecycle.addListener(RequestManager.this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    lifecycle.addListener(this);</span><br><span class="line">&#125;</span><br><span class="line">lifecycle.addListener(connectivityMonitor);</span><br></pre></td></tr></table></figure><p>上面是RequestManager初始化的代码一部分.RequestManager实现了LifecycleListener接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class RequestManager implements LifecycleListener &#123;</span><br></pre></td></tr></table></figure><p>它实现接口做的工作是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onStop() &#123;</span><br><span class="line">    pauseRequests();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Lifecycle callback that cancels all in progress requests and clears and recycles resources for all completed</span><br><span class="line"> * requests.</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void onDestroy() &#123;</span><br><span class="line">    requestTracker.clearRequests();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看注释和代码命名就大概能推测到在Stop和Destroy的时候会分别暂停和取消请求,到这里我们大概就知道了具体的实现逻辑了.</p><p><strong>总结一下:Glide.with的时候会为context添加一个空白的Fragment,通过监听Fragment的生命周期,会在每次发生改变的时候遍历LifecycleListener,其实也就是RequestManager,调用其onStop,onDestroy方法达到暂停和取消请求的目的.</strong></p><p>完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本人在使用Glide图片下载框架的时候,一直有一个疑惑,它到底是怎么做到Context在Destory的时候自动停止下载请求的,带着好奇心的驱使我去了解了下源码,心里大概知道了真相.&lt;/p&gt;
&lt;p&gt;一般我们要下载图片，Glide是这样做的：&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android AudioRecord音频录制实现暂停功能</title>
    <link href="http://yoursite.com/2019/03/13/Android%20AudioRecord%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%E5%AE%9E%E7%8E%B0%E6%9A%82%E5%81%9C%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2019/03/13/Android AudioRecord音频录制实现暂停功能/</id>
    <published>2019-03-13T09:58:45.000Z</published>
    <updated>2019-03-13T12:06:03.790Z</updated>
    
    <content type="html"><![CDATA[<p>AudioRecord官方API并没有实现音频暂停功能，Google了半天也没有找到具体的好的实现方法，所以我打算自己实现。先回顾一下音频开始录制的具体实现。</p><ol><li><p>首先先得初始化AudioRecord对象 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">audioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC, SAMPLE_RATE_INHZ,</span><br><span class="line">        CHANNEL_CONFIG, AUDIO_FORMAT, minBufferSize);</span><br></pre></td></tr></table></figure></li></ol><p>​       上面的参数具体指声道数,采样率以及最小缓冲区。</p><ol start="2"><li><p>新建文件用来存储录制的音频数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final File file = new File(getExternalFilesDir(Environment.DIRECTORY_MUSIC),</span><br><span class="line">        &quot;wenwenrecord.pcm&quot;);</span><br></pre></td></tr></table></figure></li><li><p>开启一个线程不断的往文件里面写数据</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    //往文件里面写数据</span><br><span class="line">    audioRecord.read(data, 0, minBufferSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p><strong>问题来了，官方只提供给了我们录制音频的接口，并没有提供暂停和停止的接口，该怎么实现呢？</strong></p><p>嗯，其实只要仔细想一下就知道了，我在上面开启了一个线程往文件里面写数据，只需要定义一个标志变量用来判断是否继续写入数据就行了。如果是暂停录制就不执行audioRecord.read，如果是停止录制就跳出while循环。具体实现如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        FileOutputStream os = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            os = new FileOutputStream(file);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (null != os) &#123;</span><br><span class="line">            while (currentAudioState.get() == PAUSE_STATE ||</span><br><span class="line">                    currentAudioState.get() == REDORDING_STATE) &#123;</span><br><span class="line">                if (currentAudioState.get() == PAUSE_STATE) &#123;</span><br><span class="line">                    LogUtil.i(&quot;Record&quot;, &quot;pause...&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    int read = audioRecord.read(data, 0, minBufferSize);</span><br><span class="line">                 </span><br><span class="line">                    if (AudioRecord.ERROR_INVALID_OPERATION != read) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            os.write(data);</span><br><span class="line">                        &#125; catch (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                LogUtil.i(TAG, &quot;run: close file output stream !&quot;);</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>这里的currentAudioState定义为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 当前录音状态</span><br><span class="line"> */</span><br><span class="line">private AtomicInteger currentAudioState = new AtomicInteger(STOP_STATE);</span><br></pre></td></tr></table></figure><p>为了保证在多线程环境下的原子操作我用了并发包里的AtomicInteger。</p><p>完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AudioRecord官方API并没有实现音频暂停功能，Google了半天也没有找到具体的好的实现方法，所以我打算自己实现。先回顾一下音频开始录制的具体实现。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先先得初始化AudioRecord对象 &lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
  </entry>
  
</feed>
